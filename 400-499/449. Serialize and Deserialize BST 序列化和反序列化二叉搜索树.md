
- ä½œè€…ï¼š è´Ÿé›ªæ˜çƒ›
- idï¼š	fuxuemingzhu
- ä¸ªäººåšå®¢ï¼š	[http://fuxuemingzhu.cn/](http://fuxuemingzhu.cn/)
- å…³é”®è¯ï¼šåŠ›æ‰£ï¼ŒLeetCodeï¼Œç®—æ³•ï¼Œé¢˜è§£ï¼Œè§£æï¼Œ449ï¼ŒPython, C++, äºŒå‰æœç´¢æ ‘ï¼Œåºåˆ—åŒ–ï¼Œååºåˆ—åŒ–

---
@[TOC](ç›®å½•)


é¢˜ç›®åœ°å€ï¼š[https://leetcode.cn/problems/serialize-and-deserialize-bst/](https://leetcode.cn/problems/serialize-and-deserialize-bst/)

## é¢˜ç›®æè¿°
åºåˆ—åŒ–æ˜¯å°†æ•°æ®ç»“æ„æˆ–å¯¹è±¡è½¬æ¢ä¸ºä¸€ç³»åˆ—ä½çš„è¿‡ç¨‹ï¼Œä»¥ä¾¿å®ƒå¯ä»¥å­˜å‚¨åœ¨æ–‡ä»¶æˆ–å†…å­˜ç¼“å†²åŒºä¸­ï¼Œæˆ–é€šè¿‡ç½‘ç»œè¿æ¥é“¾è·¯ä¼ è¾“ï¼Œä»¥ä¾¿ç¨ååœ¨åŒä¸€ä¸ªæˆ–å¦ä¸€ä¸ªè®¡ç®—æœºç¯å¢ƒä¸­é‡å»ºã€‚

è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ– äºŒå‰æœç´¢æ ‘ ã€‚ å¯¹åºåˆ—åŒ–/ååºåˆ—åŒ–ç®—æ³•çš„å·¥ä½œæ–¹å¼æ²¡æœ‰é™åˆ¶ã€‚ æ‚¨åªéœ€ç¡®ä¿äºŒå‰æœç´¢æ ‘å¯ä»¥åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”å¯ä»¥å°†è¯¥å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºæœ€åˆçš„äºŒå‰æœç´¢æ ‘ã€‚

ç¼–ç çš„å­—ç¬¦ä¸²åº”å°½å¯èƒ½ç´§å‡‘ã€‚

 

ç¤ºä¾‹ 1ï¼š

	è¾“å…¥ï¼šroot = [2,1,3]
	è¾“å‡ºï¼š[2,1,3]

ç¤ºä¾‹ 2ï¼š

	è¾“å…¥ï¼šroot = []
	è¾“å‡ºï¼š[]
 

æç¤ºï¼š

- æ ‘ä¸­èŠ‚ç‚¹æ•°èŒƒå›´æ˜¯ `[0, 10^4]`
- `0 <= Node.val <= 10^4`
- é¢˜ç›®æ•°æ® ä¿è¯ è¾“å…¥çš„æ ‘æ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘ã€‚


æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
é“¾æ¥ï¼šhttps://leetcode.cn/problems/serialize-and-deserialize-bst
è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚


å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ [@è´Ÿé›ªæ˜çƒ›](https://leetcode-cn.com/u/fuxuemingzhu/)ã€‚ğŸ‘ˆğŸ‘ˆ ç‚¹å‡»å…³æ³¨ï¼Œä¼˜è´¨é¢˜è§£ä¸é—´æ–­ã€‚

## é¢˜ç›®å¤§æ„

é¦–å…ˆè¦æ˜ç™½é¢˜æ„ï¼š

- **åºåˆ—åŒ–**ï¼šæŠŠå†…å­˜ä¸­çš„**äºŒå‰æœç´¢æ ‘**è½¬æˆ**å­—ç¬¦ä¸²**ï¼›
- **ååºåˆ—åŒ–**ï¼šæŠŠ**å­—ç¬¦ä¸²**æ¢å¤æˆå†…å­˜ä¸­çš„**äºŒå‰æœç´¢æ ‘**ã€‚


![449. åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æœç´¢æ ‘.001.png](https://img-blog.csdnimg.cn/img_convert/b9005dcc399cbcacad095305e2ae374b.png)


é¢˜ç›®æ²¡æœ‰é™å®šæˆ‘ä»¬ç”¨ä»€ä¹ˆæ–¹æ³•ï¼Œåªè¦æ±‚æˆ‘ä»¬åºåˆ—åŒ–åçš„å­—ç¬¦ä¸²å°½å¯èƒ½ç´§å‡‘ã€‚

è§£æ³•ä¸å›ºå®šï¼Œåªè¦åºåˆ—åŒ–åçš„ç»“æœï¼Œèƒ½è¢«ååºåˆ—åŒ–å‡½æ•°è¿˜åŸæˆä¸€æ¨¡ä¸€æ ·çš„**äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰**ï¼Œéƒ½è®¤ä¸ºæ˜¯æ­£ç¡®ç­”æ¡ˆã€‚

è¯„æµ‹çš„è¿‡ç¨‹æ˜¯ä¸‹é¢è¿™æ ·ï¼š

```C++
Codec ser = new Codec();
Codec deser = new Codec();
String tree = ser.serialize(root);
TreeNode ans = deser.deserialize(tree);
return ans;
```



## è§£é¢˜æ–¹æ³•

### å‰åºéå† + é€’å½’

BST çš„åŸºæœ¬å®šä¹‰ï¼š

- **BST çš„å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹éƒ½æ¯”æ ¹èŠ‚ç‚¹å€¼å°ï¼Œå³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹éƒ½æ¯”æ ¹èŠ‚ç‚¹å€¼å¤§ã€‚**

åªçŸ¥é“æ ‘çš„ä¸€ç§éå†æ–¹å¼ï¼Œæ˜¯æ²¡æ³•ç¡®å®šè¿™ä¸ªæ ‘çš„ï¼ŒBST ä¹Ÿä¸ä¾‹å¤–ã€‚

å› æ­¤ï¼Œæˆ‘çš„ä¸»è¦æ€è·¯å°±æ˜¯ï¼šé‡‡ç”¨**å‰åºéå†**çš„åºåˆ—åŒ– BSTï¼Œå†æ ¹æ® BST çš„æ€§è´¨è¿›è¡Œååºåˆ—åŒ–ã€‚


1. åºåˆ—åŒ–çš„è¿‡ç¨‹ï¼š

é‡‡ç”¨å‰åºéå†ï¼Œè½¬åŒ–æˆå­—ç¬¦ä¸²ã€‚

![449. åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æœç´¢æ ‘.002.png](https://img-blog.csdnimg.cn/img_convert/fa6a040c6c563dc274ad6ae28e60e43e.png)


2. ååºåˆ—åŒ–çš„è¿‡ç¨‹ï¼š

    - **å‰åºéå†**å¾—åˆ°çš„æ•°ç»„çš„ç¬¬ä¸€ä¸ªå€¼å°±æ˜¯ BST çš„**æ ¹èŠ‚ç‚¹**
    - æ•°ç»„åé¢çš„è¿™äº›æ•°ä¸­æ¯”æ ¹èŠ‚ç‚¹çš„å€¼**å°**çš„æ˜¯æ ¹èŠ‚ç‚¹çš„**å·¦å­æ ‘**ï¼Œæ¯”æ ¹èŠ‚ç‚¹å€¼**å¤§**çš„æ˜¯æ ¹èŠ‚ç‚¹çš„**å³å­æ ‘**
    - **é€’å½’**å°±å¯ä»¥ååºåˆ—åŒ–å‡ºåŸæœ¬çš„ BST

![449. åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æœç´¢æ ‘.003.png](https://img-blog.csdnimg.cn/img_convert/f662a78629400cd126a1aa9a78a82dfe.png)




Pythonè¯­è¨€ä»£ç å¦‚ä¸‹ï¼š

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        vals = []
        def preOrder(root):
            if root:
                vals.append(root.val)
                preOrder(root.left)
                preOrder(root.right)
        preOrder(root)
        return ','.join(map(str, vals))


    def deserialize(self, data):
        if not data or data == '':
            return None
        vals = map(int, data.split(","))
        root = TreeNode(vals[0])
        leftVals = [x for x in vals if x < vals[0]]
        rightVals = [x for x in vals if x > vals[0]]
        root.left = self.deserialize(",".join(map(str, leftVals)))
        root.right = self.deserialize(",".join(map(str, rightVals)))
        return root
        

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# tree = ser.serialize(root)
# ans = deser.deserialize(tree)
# return ans
```

C++ ä»£ç å¦‚ä¸‹ï¼š
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    void preOrder(TreeNode* root, vector<int>& res) {
        if (!root) return;
        res.push_back(root->val);
        preOrder(root->left, res);
        preOrder(root->right, res);
    }

    string vector2string(vector<int>& vals) {
        string res;
        if (vals.empty()) return res;
        for (int i = 0; i < vals.size() - 1; ++i) {
            res += to_string(vals[i]) + ",";
        }
        res += to_string(vals[vals.size() - 1]);
        return res;
    }

    vector<int> split(string& s) {
        vector<int> res;
        size_t pos = 0;
        std::string token;
        while ((pos = s.find(",")) != std::string::npos) {
            token = s.substr(0, pos);
            res.push_back(stoi(token));
            s.erase(0, pos + 1);
        }
        res.push_back(stoi(s));
        return res;
    }

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        vector<int> vals;
        preOrder(root, vals);
        return vector2string(vals);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data.empty()) return nullptr;
        vector<int> vals = split(data);
        TreeNode* root = new TreeNode(vals[0]);
        vector<int> leftVals;
        vector<int> rightVals;
        for (int val : vals) {
            if (val < vals[0]) {
                leftVals.push_back(val);
            } else if (val > vals[0]) {
                rightVals.push_back(val);
            }
        }
        root->left = deserialize(vector2string(leftVals));
        root->right = deserialize(vector2string(rightVals));
        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec* ser = new Codec();
// Codec* deser = new Codec();
// string tree = ser->serialize(root);
// TreeNode* ans = deser->deserialize(tree);
// return ans;
```

å¤æ‚åº¦ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼šåºåˆ—åŒ–æ˜¯ $O(N)$ï¼›ååºåˆ—åŒ–æœ€å·®è¾¾åˆ° $O(N^2)$ï¼Œå› ä¸ºå½“æ ‘çš„èŠ‚ç‚¹éƒ½åå‘äºä¸€ä¾§çš„æ—¶å€™ï¼Œæ¯éå†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½è¦å¯¹è®¿é—®å‰©ä½™çš„ $N - 1$ä¸ªèŠ‚ç‚¹ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼šåºåˆ—åŒ–æ˜¯ $O(N)$ï¼›ååºåˆ—åŒ–æœ€å·®è¾¾åˆ° $O(N^2)$ï¼Œç†ç”±åŒä¸Šã€‚

### å‰åºéå† + é˜Ÿåˆ—

åœ¨ååºåˆ—åŒ–çš„è¿‡ç¨‹ä¸­ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä¸€ä¸ªé˜Ÿåˆ—è¿›è¡Œæ“ä½œã€‚

python ä»£ç å¦‚ä¸‹ï¼š

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:
    
    def serialize(self, root):
        """Encodes a tree to a single string.
        :type root: TreeNode
        :rtype: str
        """
        vals = []
        def preOrder(root):
            if root:
                vals.append(root.val)
                preOrder(root.left)
                preOrder(root.right)
        preOrder(root)
        return ' '.join(map(str, vals))

    
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        :type data: str
        :rtype: TreeNode
        """
        vals = collections.deque(int(val) for val in data.split())
        def build(minVal, maxVal):
            if vals and minVal < vals[0] < maxVal:
                val = vals.popleft()
                root = TreeNode(val)
                root.left = build(minVal, val)
                root.right = build(val, maxVal)
                return root
        return build(float('-inf'), float('inf'))

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
```

## æ€»ç»“

1. æ²¡æœ‰å›ºå®šå¥—è·¯çš„é¢˜ç›®ï¼Œéœ€è¦è‡ªå·±å‘æ˜æ•°æ®ç»“æ„çš„æ€§è´¨ï¼Œæ‰¾åˆ°åˆé€‚çš„è§£æ³•ã€‚

## æ—¥æœŸ

2018 å¹´ 3 æœˆ 12 æ—¥ 
2021 å¹´ 5 æœˆ 11 æ—¥ â€”â€” æœ€è¿‘ç²¾åŠ›æ„Ÿè§‰è·Ÿä¸ä¸Šäº†